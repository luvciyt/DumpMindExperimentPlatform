# Week1.md

## date：2025-7-12

本周主要对 kernel_builder 工具进行了架构重构与语言迁移。本次重构采用 Rust 作为主要开发语言，替代原有基于 Golang 的实现。选择 Rust 的原因主要包括以下几点：

1. 更强的类型与内存安全保障：Rust 拥有先进的编译器静态分析能力，能够在编译期捕获常见的内存错误和线程数据竞争，显著提升构建工具的健壮性。

2. 生态丰富且系统级能力强：Rust 的生态提供了包括命令执行（如 std::process::Command）、文件系统操作、异步 IO 等在内的一系列高质量 crate，既能胜任底层系统任务，也能高效处理高层逻辑。

3. 构建体验更好：相比 Golang，Rust 在代码组织和错误处理方面提供了更细粒度的控制，有助于构建更可维护、更可靠的内核构建流水线。

在构建 Linux 内核的过程中，环境配置 是长期存在的一大难点。特别是在编译旧版本内核（如 Linux 5.x 甚至 4.x）时，新的编译器（如 GCC 13+ 或 Clang 17+）往往会因为旧代码中不符合当前标准的写法而产生编译错误。例如某些已弃用的语法、旧的头文件引用方式、对 inline 等关键字语义的不同处理等。

因此，为了确保构建成功，往往需要一个与目标内核版本匹配的旧版本编译器工具链。本次重构在架构设计中引入了对编译环境的版本管理机制，配合 Nix 提供的可复现构建能力，可针对不同内核版本自动生成对应的工具链和依赖环境，从而显著提升构建稳定性和自动化程度。

此外，为了解决内核编译过程中复杂的依赖管理问题，本次重构特别引入了 nix-shell 作为构建环境的管理工具。这一选择的主要动因如下：

1. 构建环境的高度可复现性：Linux 内核的构建对工具链的版本高度敏感，尤其是老版本内核在使用新版 GCC 或 Clang 时可能会因语法或行为差异而导致编译失败。传统包管理器难以精准控制工具链版本，且在多人协作或 CI/CD 场景中容易引发“它在我机器上可以”的问题。而 Nix 的声明式构建模型可以确保每次进入 nix-shell 都拥有完全一致的编译环境，大幅降低环境不一致导致的问题。

2. 依赖声明明确且自动化：借助 nix-shell，只需在 shell.nix 中明确列出所需依赖（如特定版本的 gcc、bison、flex、libelf、openssl 等），即可自动拉取和配置完整工具链，无需手动安装系统包或额外维护虚拟环境。

3. 支持跨平台与交叉编译：Nix 对不同平台和交叉编译的支持极其成熟，能够方便地构建如 aarch64, riscv64 等多架构内核，且依赖包的隔离性和可组合性远超传统交叉编译工具链。

4. 与 Rust 工具链良好集成：Rust 社区已有良好的 Nix 集成实践（如 crate2nix, naersk 等），本项目结合 Rust + Nix 可以统一管理 Rust 工具链和 C 编译器环境，极大简化开发与测试流程。

综上，通过引入 nix-shell，不仅解决了内核编译过程中对工具链精细控制的需求，也为未来实现构建环境的模块化、自动化和可移植性奠定了基础。

目前正在进行的工作是环境的配置与kernel-build这一部分的编写，目前已基本完成下载和编译linux内核，之后需要做的是配置ssh和qemu.

`!TODO`:为 patch generate 和 recompile 留出接口并进行逻辑的编写 

## date: 2025-7-17
